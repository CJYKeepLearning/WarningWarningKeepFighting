动态规划：博弈问题

题目：

你和你的朋友面前有一排石头堆，用一个数组 piles 表示，piles[i] 表示第 i 堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。

石头的堆数可以是任意正整数，石头的总数也可以是任意正整数，这样就能打破先手必胜的局面了。比如有三堆石头 `piles = [1,100,3]`，先手不管拿 1 还是 3，能够决定胜负的 100 都会被后手拿走，后手会获胜。

**假设两人都很聪明**，请你设计一个算法，返回先手和后手的最后得分（石头总数）之差。比如上面那个例子，先手能获得 4 分，后手会获得 100 分，你的算法应该返回 -96。

解析：

博弈问题的前提一般都是在两个聪明人之间进行，编程描述这种游戏的一般方法是二维 dp 数组，数组中通过元组分别表示两人的最优决策。

之所以这样设计，是因为先手在做出选择之后，就成了后手，后手在对方做完选择后，就变成了先手。**这种角色转换使得我们可以重用之前的结果**，典型的动态规划标志。

dp数组定义：

对于dp\[i][j].fir表示，对于piles[i...j]这部分石头堆，先手能获得的最高分数

对于dp\[i][j].sec表示，对于piles[i...j]这部分石头堆，后手能获得的最高分

//状态转移方程

先手选择left:dp\[i][j] = piles[i]+dp\[i+1][j].sec

先手选择right:dp\[i][j] = piles[j]+dp\[i][j-1].sec

//base case

当i==j，即只有一堆的时候，fir = piles[i]; sec = 0;



斜着遍历：

![图片](https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4kMoOYkyPr0cUmyGyfs2ppnuGM9Eic8YEyugeSrcm3PjWLUfbg0UoSW1icR3mN88d02BwToiaaQKehkg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```java
for (int l=2;l<=n;l++){
     for(int i=0;i<=n-1;i++){
         int j = l+i-1;
         a[i][j];//斜着遍历
      }
}
```

